DDD
1/ Ubiquitous Language:
 - Part of DDD.
 - Aims at building a common and business oriented language.
 - Is a vocabulary of terms shared by all parties involved in the project.
 - This language should be based on the Domain Model used in the software.

2/ Bounded context:
 - Central pattern in DDD.
 - Dealing with large models and teams.
 - Deal with large models by dividing them into different Bounded Contexts and being explicit about their interrelationships.

3/ DDD Layered Architecture
 a/ Presentation Layer:
  - Responsible for providing some user interface to accomplish any tasks.
  - Whatever command is issued, the application layer is routed through the various remaining layers of the system.
  b/ Domain Layer:
   - Responsible for representing concepts of the business.
   - Contains domain entities that capture data plus behavior (methods with logic)
   - Ignores data persistence details. (Based on Persistence Ignorance and the Infrastructure Ignorance)
   - Domain model entity classes should be POCOs.
   (Domain entity model, POCO entity classes, DDD Patterns: Aggregate root, value object, repository interfaces)
  c/ Application Layer
   - Defines the jobs the software is supposed to do.
   - CQRS
  d/ Infrastructure Layer
   - Defines how in - memory data is persisted in databases or another persistent store. Ex: using EFCore code to implement the Repository pattern classes that use a DbContext to persist data in a relational database.

Domain Event
  - Use domain events to explicitly implement side effects of changes within domain.
1/ What?
  - An event is something that has happened in the past.
   => A domain event is something that happened in the domain that you want other parts of the same domain to be aware of. In other words, 
      it is used to notify other parts of the same domain that something interesting happened and these other parts potentially can react to.
  - Domain Event --> Domain Event Handler.
2/ Implement domain events
  - Is simply a class (like DTO), with all the information/data related to what just happened in the domain.
  - Class name should be represented as a past-tense verb.
  - Must be an immutable class (bất biến) ==> Properties are read-only (Not allow to change the value of the properties)
3/ Raise domain events
  - First, add the events happening in entities into a collection or list of events per entity.
    --> This step just adds the events to list / collection. No event is dispatched (phái đi, gửi đi) yet and no event handler is invoked yet.
  - Building the Event Handlers
    --> Whenever an event is issued by our system we can use an Event Handler to do something with that event.
       ==> For ex, we need our Event Handlers to update our READ data store.
  (*) NOTE: Write ---> Event ---> Event Handler ---> Event Handler saves the new data to READ db
            With the Event Handlers, every time an Event is kicked off, it will be consumed by the Event Handlers
             and the dbms (Redis, SQL Server, MariaDb, ...) that contains read model will be updated.

Fluent Validation
 - Use fluent validation when you want to treat validation logic as separate from business logic

Microservices
- Each microservice is supposed to do one thing and do it well.
- A microservice is a service built around a specific business capability,
   which can be independently deployed. Its called Bounded Context.
=> To build a large enterprise application, we have to identify the sub-domains of our main business domain,
   and build each sub-domain as a microservice. Ex: User management, Catalog, Invoicing,....
1/ Definitions
- Microservices are small services that work together.
- Each microservice lives independently, but they all rely on each other.
- Microservices solve the systems that are too big. ==> Smaller teams, easier to manage, quicker to develop and test, more agile.
2/ Microservices elements (An application includes FrontEnd - BackEnd - Database --> Draw the image from slide)
 (a) Building a Monolith (Draw the image from slide)
   - Entire backend will be deployed as a single monolithic application with its own single database.
   - Single database.
   - User interface.
   - Single monolith (Backend).
   (a.1) Pros
       - Simple to develop (but limits with a few frameworks and databases)
       - Simple to build
       - Simple to deploy
   (a.2) Cons
       - Application is too large and complex to fully understand and made changes fast and correctly.
       - Size of the application can slow down the start up time.
       - Huge database.
       - Must redeploy the entire application on each update.
 (b) Building Microservices (Draw the image from slide)
       - Split the Domain into Sub-Domains.
       - Each Sub-Domains corresponds to a different part of the business (Ex: User, Order, Product, ...)
       - Sub-Domains should be independent of each other. We can use duplicate the entitites that depend on each other technique.
         ==> Another ex, in User Domain, the user can have a profile with social media
	     and in the Order Domain, a user can have information about payment such as credit card.
             ==> Each Sub-Domain being responsible for its own processing and data, it should have its own database.
       - Sub-Domains should not share databases.
 (c) Pros and Cons
       (c.1) Pros
	   - Team / Sub-Domain.
           - We can right-sized teams (small sub-domain, big sub-domain).
           - Each team is totally independent. (Even if the teams are all independent,
              those microservices end up communicating with each other)
       (c.2) Cons
  (d) Codebase
      - Each sub-domain has its own repository.
      - Each sub-domain must be versioned.
  (e) Data Store
      - In the monolith approach, the entire data of the application is stored in a single database.
      - In the microservice approach, each service needs its own independent database. Changes to one service's database does not impact any other services.
  (f) Services
      - Microservices will end up communicating with each other. That time, they need to expose (thể hiện ra) and consume necessary APIs,
        use a communication protocol. There are two popular communication styles:
	(f.1) Remote Procedure Invocation (RPC - Remote Procedure Call)
	     - Works on the request/reply principle. A service requests something to another service and this one replies back.
               --> Order microservice requests to Product microservice to get the price of a sprcific product.
               --> This call can be Synchronous or Asynchronous.
	(f.2) Messaging
             - Microservices exchange messages or events via a broker or channel.
             - When a microservice wants to interact with the other, it publishes a message to the broker. The other microservices subscribe
               to that broker if interested in such messages and receive messages at later stage. These microservices can then proceed to
               update their own state.
             - Improve availability since the message broker buffers messages until the consumer is able to process them.
             - Ex, order microservice exposes two APIs, one to create a new purchase order, and a second one to retrieve an existing one.
               For the other services to know what's exposed and how to invoke it, the order microservice exposes a contract.
  (g) Distributed Services //////////////////////
3/ Are microservices right for your organization?

Domain and Sub-Domains (Find diagram for example)
1/ Domain
   - Refers to the space of the problems for which we are acting.
2/ Sub-Domains
   - Is a subpart of the Domain.
   - Every Domain can always be divided into Subdomains, by doing this we divide the entire complexity
     of the Company's Domain into smaller parts.
   - Each Sub-Domain corresponds to a different part of the business.
3/ Domain Model
   - It's the model of the objects required for your business purposes.
   --> Ex: The entire set of classes, as well as the relationships between them, would constitute Domain Model.

(*) Research more about Event - Sourcing pattern.
(*) Research about Kafka.
(*) Research about RPC and Messaging.